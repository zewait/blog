<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[webpack搭建react构建环境]]></title>
      <url>http://blog.00ps.win/2016/12/16/webpack%E6%90%AD%E5%BB%BAreact%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<h1 id="Babel和Webpack"><a href="#Babel和Webpack" class="headerlink" title="Babel和Webpack"></a>Babel和Webpack</h1><p>事实上react并不需要这些工具就能运行；但是为了充分使用 <a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">ES6</a>、<a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX</a> 和bunding</p>
<a id="more"></a>
<h1 id="让我们重新配置"><a href="#让我们重新配置" class="headerlink" title="让我们重新配置"></a>让我们重新配置</h1><p>新建一个react-hello-world文件夹并用npm初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir react-hello-world</div><div class="line">cd react-hello-world</div><div class="line">npm init</div></pre></td></tr></table></figure></p>
<h1 id="安装并配置webpack"><a href="#安装并配置webpack" class="headerlink" title="安装并配置webpack"></a>安装并配置webpack</h1><p><a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">Webpack</a>可以根据配置文件将依赖文件和资源文件打包在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 安装并保存webpack到package.json里面</div><div class="line">npm install webpack —save-dev</div><div class="line"># 安装webpack的全局命令</div><div class="line">npm install -g webpack-cli</div></pre></td></tr></table></figure></p>
<p>webpack需要一些配置来指定他如何工作，最佳实践就是把配置写进去webpack.config.js<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> BUILD_DIR = path.resolve(__dirname, <span class="string">'build'</span>);</div><div class="line"><span class="keyword">var</span> APP_DIR = path.resolve(__dirname, <span class="string">'src'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="string">'index_bundle.js'</span>: path.resolve(APP_DIR, <span class="string">'index.js'</span>),</div><div class="line">  &#125;</div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: BUILD_DIR,</div><div class="line">    <span class="comment">// [name]指的是entry对象里面的key</span></div><div class="line">    filename: <span class="string">'[name]'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure><br>以上是webpack配置文件的最小化配置，只需要提供entry(入口)和output(输出)</p>
<p><code>APP_DIR</code>是源码文件夹，<code>BUILD_DIR</code>是最终打包生成输出的文件夹</p>
<p>在src下创建<code>index.js</code>验证下此配置<br><figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure><br>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -d</div></pre></td></tr></table></figure></p>
<p>上面命令运行了webpack的开发模式，它会生成build/index_bundle.js和关联build/index_bundle.js的映射文件index_build.js.map</p>
<p>为了得到更多的交互我们创建index.html<br><figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React.js use jsx and es6<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle/index_bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><br>现在我们打开index.html，会在浏览器的console中看到输出</p>
<p>NOTE: <a href="https://github.com/webpack/html-loader" target="_blank" rel="external">html-loader</a>允许我们自动生成上述index.html文件</p>
<h1 id="激活babel"><a href="#激活babel" class="headerlink" title="激活babel"></a>激活babel</h1><p>jsx和es6让react能让有更高的开发效率，但是目前几乎所有浏览器都不支持。</p>
<p>因此我们需要个工具来转换他们，令到浏览器能识别，它就是<a href="http://babeljs.io/" target="_blank" rel="external">babel</a></p>
<figure class="highlight plain"><figcaption><span>转换流程</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</div><div class="line">&gt;  &lt;p&gt;Hello&lt;/p&gt;  &gt;  ===&gt;    &gt;  babel-loader  &gt;  ===&gt; &gt;  React.createElement(&apos;p&apos;, ...)  &gt;</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</div><div class="line">     index.js                    webpack                       index_bundle.js</div><div class="line"></div></pre></td></tr></table></figure>
<p>安装babel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev</div></pre></td></tr></table></figure></p>
<p><code>babel-preset-es2015</code>和<code>babel-preset-react</code>是<code>babel-loader</code>的插件，用来转换es6和jsx</p>
<p>babel-loader是读取一个配置文件，所以能在配置文件中声明使用转换es6和react的插件<br><figure class="highlight js"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span> : [<span class="string">"es2015"</span>, <span class="string">"react"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下一步我们使用babel-loader来打包文件<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Existing Code ....</span></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="comment">// Existing Code ....</span></div><div class="line">  <span class="built_in">module</span> : &#123;</div><div class="line">    <span class="attr">loaders</span> : [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span> : <span class="regexp">/\.js$/</span>,</div><div class="line">        <span class="attr">include</span> : APP_DIR,</div><div class="line">        <span class="attr">loader</span> : <span class="string">'babel'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>loaders</code>接收一组loader，我们只使用了babel-loader。每个loader都会处理匹配<code>test</code>内容的文件。 这里我们配置了babel-loader处理.js后缀的文件。loader会在<code>include</code>指定的文件夹中遍历寻找符合<code>test</code>规则的文件。</p>
<p>目前所有配置都准备就绪了。让我们写点react吧</p>
<h1 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h1><p>安装react和react-dom<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i react react-dom --save</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> Hello React!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</div></pre></td></tr></table></figure>
<p>如果还打开着index.html页面，刷新下会看到<em>Hello React!</em></p>
<h1 id="webpack监听文件更改"><a href="#webpack监听文件更改" class="headerlink" title="webpack监听文件更改"></a>webpack监听文件更改</h1><p>每次更改都需要手动运行命令，这不是一个高效的工作流。我们可以很简单的使用以下命令来监听文件修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -d --watch</div></pre></td></tr></table></figure></p>
<p>现在以watch模式运行着webpack，当文件更改或者删除的时候会自动生成bundel。我们可以试试修改src/index.js，然后刷新浏览器看效果</p>
<h1 id="让一切”自动”起来"><a href="#让一切”自动”起来" class="headerlink" title="让一切”自动”起来"></a>让一切”自动”起来</h1><p>为了能更专心coding，我们希望能<code>所编即所见</code>。我们需要用到<a href="https://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a><br><figure class="highlight plain"><figcaption><span>安装webpack-dev-server命令行工具</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g webpack-dev-server</div></pre></td></tr></table></figure><br>webpack-dev-server能提供server服务和监听修改刷新浏览器，让我们配置下它<br><figure class="highlight js"><figcaption><span>webpack.coding.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Existing Code ....</span></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="comment">// Existing Code ....</span></div><div class="line">    filename: <span class="string">'[name]'</span>,</div><div class="line">    <span class="comment">// webpack-dev-server 输出路径</span></div><div class="line">    publicPath: <span class="string">'/build/'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Existing Code ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><code>publicPath</code>是webpack-dev-server输出文件的路径，这只是个映射，映射到内存中的一部分，并不真的会在build下生成文件。</p>
<p>启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server</div></pre></td></tr></table></figure></p>
<p>我们就可以通过<a href="http://localhost:8080/webpack-dev-server/" target="_blank" rel="external">http://localhost:8080/webpack-dev-server/</a>来访问到index.html文件。现在试下做下修改看浏览器有什么变化？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[react-native笔记-基础篇]]></title>
      <url>http://blog.00ps.win/2016/11/23/react-native%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87/</url>
      <content type="html"><![CDATA[<p>#Component</p>
<ul>
<li>定义组件首字必须大小，用于区分普通html元素</li>
</ul>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>可用于定制组件，等同于htm中的attribute。<br>贯穿整个生命周期，不得做任何改变<br><a id="more"></a></p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><a href="https://facebook.github.io/react/docs/react-component.html#defaultprops" target="_blank" rel="external">defaultProps</a></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#proptypes" target="_blank" rel="external">proptypes</a></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#props" target="_blank" rel="external">props</a><br>this.props.children该组件下的子组件</li>
</ul>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>跟props一样用于定制组件用，不同的是state可以被修改<br>在构造器初始化，当你想改变组件状态的时候调用setState，<br>组件重新render，除非shouldComponentUpdate()返回false</p>
<h2 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><a href="https://facebook.github.io/react/docs/react-component.html#state" target="_blank" rel="external">state</a><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#setstate" target="_blank" rel="external">setState</a><br>此方法不是重新设置state，而是合并</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="external">State and Lifecycle</a></li>
<li><a href="http://redux.js.org/index.html" target="_blank" rel="external">更好的控制状态Redux</a></li>
</ul>
<h1 id="style"><a href="#style" class="headerlink" title="style"></a>style</h1><p>跟html的style差不多，不同的是background-color这些要写成backgroundColor。<br>style能是普通的js对象，也能是使用StyleSheet.create来创建。<br>更推荐的是使用StyleSheet.create在组件的同一个地方创建</p>
<h2 id="StyleSheet-create-vs-普通js对象"><a href="#StyleSheet-create-vs-普通js对象" class="headerlink" title="StyleSheet.create vs 普通js对象"></a>StyleSheet.create vs 普通js对象</h2><ul>
<li>StyleSheet.create创建返回的是一个id，通过StyleSheetRegistry.getStyleByID获取该id<br>指向的对象</li>
<li>用StyleSheet.create创建代替每次都创建新的对象</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安装httpd并整合tomcat]]></title>
      <url>http://blog.00ps.win/2015/05/02/%E5%AE%89%E8%A3%85httpd%E5%B9%B6%E6%95%B4%E5%90%88tomcat/</url>
      <content type="html"><![CDATA[<h1 id="安装httpd"><a href="#安装httpd" class="headerlink" title="安装httpd"></a>安装httpd</h1><p>下载<a href="http://httpd.apache.org/" target="_blank" rel="external">httpd</a>并解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">weget http://mirrors.hust.edu.cn/apache//httpd/httpd-2.2.29.tar.gz</div><div class="line">tar -zxvf httpd-2.2.29.tar.gz</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>配置编译安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">cd httpd-2.2.29</div><div class="line">#prefix是指定了安装位置</div><div class="line">./configure --prefix=/usr/local/apache2 \      # 安装目录</div><div class="line">--enable-modules=most \                        # 大部分模块静态编译到httpd的二进制文件中</div><div class="line">--enable-mods-shared=all \                     # 表示动态加载所有模块,如果去掉shared的话,是静态加载所有模块</div><div class="line">--enable-so \</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>
<p>以上没有错误就启动httpd, 注意:因为还没加进服务，所以需要到httpd安装目录下用前端控制工具启动(不能用service httpd start)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/apache2/bin/apachectl start</div></pre></td></tr></table></figure><br>打开浏览器浏览<a href="http://localhost" target="_blank" rel="external">http://localhost</a>看见It’s ok就代表httpd安装并启动成功了</p>
<p>加进服务和开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">cp /usr/local/apache2/bin/apachectl /init.d/httpd</div><div class="line">ln -s /etc/init.d/httpd /etc/rc.d/rc5.d/S85httpd</div><div class="line"># 运行chkconfig --list发现列表中并没有httpd,通过chkconfig --add httpd来添加,</div><div class="line"># 可能会提示httpd服务不支持chkconfig,需要编辑/etc/init.d/httpd,加入注析#chkconfig 345 85 15</div><div class="line"># 345代表哪些linux级别需要启动httpd,启动序号85 关闭序号15</div><div class="line">chkconfig --add httpd</div><div class="line"># 发现存在了</div><div class="line">chkconfig --list httpd</div><div class="line"># 接下来就可能用service http命令关闭和启动httpd了</div><div class="line"></div><div class="line"># 加进开机启动</div><div class="line">chkconfig httpd on</div></pre></td></tr></table></figure></p>
<h1 id="整合tomcat"><a href="#整合tomcat" class="headerlink" title="整合tomcat"></a>整合tomcat</h1><p>在/usr/local/apache2/conf/httpd.conf最后加上Include conf/extra/tomcat-vhosts.conf,<br>编辑/usr/local/apache2/conf/extra/tomcat-vhosts.conf<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># enable name virtual</div><div class="line">NameVirtualHost *:80</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></div><div class="line">  ServerName test.h4fan.com</div><div class="line">  DocumentRoot /path/to/project/root</div><div class="line">  ProxyPass / http://localhost:8080/</div><div class="line">  ProxyPassReverse / http://localhost:8080/</div><div class="line">  ErrorLog "logs/test-error.log"</div><div class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>重启httpd,发现出错了<br><em>Invalid command ‘ProxyPass’, perhaps misspelled or defined by a module not included in the server configuration</em><br>需要安装proxy等模块</p>
<p>介绍下添加模块的命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/apache2/bin/apxs -c -i -a mod_proxy.c proxy_util.c</div></pre></td></tr></table></figure><br>说明:<br>-c 执行编译操作<br>-i 安装操作,安装一个或多个动态共享对象到modules目录<br>-a 自动增加一个LoadModule到httpd.conf文件,以激活模块,若此存在则启动之<br>-A 与-a类似,但是它增加的LoadModule前面加有#<br>-e 需要执行编辑操作,可与-a和-A选项配合使用,与-i操作类似,修改httpd.conf文件,但并不安装此模块</p>
<p>切换到源代码目录下的/modules/proxy,执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#/usr/local/apache2/bin/apxs -c -i -a mod_proxy.c proxy_util.c</div><div class="line">#/usr/local/apache2/bin/apxs -c -i -a mod_proxy_http.c</div><div class="line">#/usr/local/apache2/bin/apxs -c -i -a mod_proxy_ajp.c ajp*.c</div></pre></td></tr></table></figure></p>
<p>现在再启动httpd就没出错了</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[判断指定区间(或操作符实现)]]></title>
      <url>http://blog.00ps.win/2014/10/22/%E5%88%A4%E6%96%AD%E6%8C%87%E5%AE%9A%E5%8C%BA%E9%97%B4-%E6%88%96%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>一般求一个值是否在指定区间为i&gt;=min&amp;&amp;i&lt;=max，但今天从网上看到这么一种写法((i-min)|(max-i))&gt;=0，原理很简单，只要i-min或者max-i其中为负数的时候，说明已经超出了区间，或操作得出的数字必定为负数</p>
]]></content>
    </entry>
    
  
  
</search>
