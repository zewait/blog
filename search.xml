<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[音频反向问题]]></title>
      <url>http://blog.00ps.win/2022/04/16/%25E9%259F%25B3%25E9%25A2%2591%25E5%258F%258D%25E5%2590%2591%25E9%2597%25AE%25E9%25A2%2598/</url>
      <content type="html"><![CDATA[<h1 id="什么是音频反向？"><a href="#什么是音频反向？" class="headerlink" title="什么是音频反向？"></a>什么是音频反向？</h1><p>音频左右声道波形图相反。这会导致混音的时候声音互相抵消掉，变成静音。</p>
<a id="more"></a>
<p><img src="/resources/音频反向问题/audio_phase.png" alt="波形相反"></p>
<h1 id="如何检查出音频是否反向"><a href="#如何检查出音频是否反向" class="headerlink" title="如何检查出音频是否反向"></a>如何检查出音频是否反向</h1><h2 id="1-制造反向音频数据"><a href="#1-制造反向音频数据" class="headerlink" title="1. 制造反向音频数据"></a>1. 制造反向音频数据</h2><p>音频文件下载: <a href="resources/音频反向问题/original.wav">original.wav</a><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i origin.wav -af &quot;pan=stereo|c0=c1|c1=c1,aeval=val(0)|-val(1)&quot; invert_phase.wav</span><br><span class="line">命令说明：</span><br><span class="line">pan=stereo|c0=c1|c1=c1 - 将左声道替换为右声道，统一声道</span><br><span class="line">aeval=val(0)|-val(1) - 反向右声道</span><br></pre></td></tr></table></figure></p>
<h2 id="2-提取出pcm数据"><a href="#2-提取出pcm数据" class="headerlink" title="2. 提取出pcm数据"></a>2. 提取出pcm数据</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 提取出大端序（方便阅读）的pcm数据，每个样本占16位</span></span><br><span class="line">ffmpeg -i inver_phase.wav -ar 44100 -ac 2 -f s16be inver_phase_44100_2_s16be.pcm</span><br></pre></td></tr></table></figure>
<h2 id="3-分析pcm数据，找出反向数据的特点"><a href="#3-分析pcm数据，找出反向数据的特点" class="headerlink" title="3. 分析pcm数据，找出反向数据的特点"></a>3. 分析pcm数据，找出反向数据的特点</h2><p>pcm数据结构如下<br><img src="/resources/音频反向问题/pcm_data_struct.png" alt="pcm数据结构"><br>如果音频反向了，左右声道在转成单声道的时候降为是静音；转换规则：左声道+右声道<br>下面使用imhex打开pcm文件分析。每2个字节为一个采样样本，基数个为左声道，偶数个为右边声道；<br>从数据上看两两左右声道相加得出为0（静音）<br><img src="/resources/音频反向问题/imhex_pcm.png" alt="imhex分析pcm"><br><strong>至此我们得出只要多声道数据相加为0就可能存在反向问题，注意这里是可能存在问题，还得结合多个样本分析</strong></p>
<h1 id="如何修复"><a href="#如何修复" class="headerlink" title="如何修复"></a>如何修复</h1><ol>
<li>将其中一个声道做下反向操作</li>
<li>延迟声道（适用于音频录制造成的问题）。可以用ffmpeg的<a href="https://ffmpeg.org/ffmpeg-filters.html#adelay">adelay过滤器</a></li>
</ol>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://www.cnblogs.com/codertian/p/6657844.html">多媒体基础知识之PCM数据</a></li>
<li><a href="https://blog.landr.com/out-of-phase-audio/">What is Out of Phase Audio and How to Fix It</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> 多媒体 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ffmpeg </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM性能优化：构建高性能Java应用的关键策略]]></title>
      <url>http://blog.00ps.win/2021/02/19/JVM%25E6%2580%25A7%25E8%2583%25BD%25E4%25BC%2598%25E5%258C%2596%25EF%25BC%259A%25E6%259E%2584%25E5%25BB%25BA%25E9%25AB%2598%25E6%2580%25A7%25E8%2583%25BDJava%25E5%25BA%2594%25E7%2594%25A8%25E7%259A%2584%25E5%2585%25B3%25E9%2594%25AE%25E7%25AD%2596%25E7%2595%25A5/</url>
      <content type="html"><![CDATA[<h1 id="JVM性能优化：构建高性能Java应用的关键策略"><a href="#JVM性能优化：构建高性能Java应用的关键策略" class="headerlink" title="JVM性能优化：构建高性能Java应用的关键策略"></a>JVM性能优化：构建高性能Java应用的关键策略</h1><p>Java虚拟机（JVM）是许多现代应用程序的关键组成部分，但要确保应用程序具有出色的性能，需要仔细优化JVM。本文将深入探讨JVM性能优化的关键策略，包括内存管理、垃圾收集、线程优化和性能分析。</p>
<a id="more"></a>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="堆内存大小"><a href="#堆内存大小" class="headerlink" title="堆内存大小"></a>堆内存大小</h3><h4 id="作用和重要性"><a href="#作用和重要性" class="headerlink" title="作用和重要性"></a>作用和重要性</h4><p>堆内存是Java应用程序用于存储对象实例的主要区域。堆内存的大小直接影响应用程序的性能和稳定性。以下是堆内存大小的作用和重要性：</p>
<ul>
<li><p><strong>垃圾收集频率</strong>：堆内存大小会影响垃圾收集的频率。如果堆太小，将导致频繁的垃圾收集，增加了应用程序的停顿时间，降低性能。</p>
</li>
<li><p><strong>内存使用效率</strong>：合理设置堆内存大小可以提高内存使用效率。如果堆内存太大，会浪费宝贵的系统资源，而太小则可能导致OutOfMemoryError异常。</p>
</li>
<li><p><strong>应用程序响应时间</strong>：适当设置堆内存大小可以减少垃圾收集的停顿时间，从而提高应用程序的响应时间。</p>
</li>
</ul>
<h4 id="调整堆内存大小"><a href="#调整堆内存大小" class="headerlink" title="调整堆内存大小"></a>调整堆内存大小</h4><p>为了合理地调整堆内存大小，你可以使用以下参数来配置：</p>
<ul>
<li><strong>-Xmx：</strong> 用于设置堆的最大大小。这是堆内存可以达到的最大限制。</li>
<li><strong>-Xms：</strong> 用于设置堆的初始大小。这是应用程序启动时分配的堆内存大小。</li>
</ul>
<p><strong>建议</strong>：根据应用程序的性能需求和工作负载，精心调整这些参数，以确保堆内存大小适合你的应用。</p>
<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="内存泄漏的概念"><a href="#内存泄漏的概念" class="headerlink" title="内存泄漏的概念"></a>内存泄漏的概念</h4><p>内存泄漏指的是应用程序在运行过程中持续分配内存，但无法释放不再需要的对象，导致内存占用不断增加。内存泄漏可能会导致应用程序的内存消耗越来越高，最终耗尽可用内存，导致应用程序崩溃。</p>
<h4 id="内存泄漏检测和解决"><a href="#内存泄漏检测和解决" class="headerlink" title="内存泄漏检测和解决"></a>内存泄漏检测和解决</h4><p>为了检测和解决内存泄漏问题，你可以采取以下措施：</p>
<ul>
<li><p>使用内存分析工具：工具如Eclipse MAT、VisualVM或YourKit可以帮助你分析内存使用情况，识别对象引用链和泄漏的资源。</p>
</li>
<li><p>定期执行内存分析：在应用程序长时间运行或大内存消耗的情况下，定期执行内存分析，以及早发现和解决潜在的内存泄漏问题。</p>
</li>
<li><p>代码审查和测试：通过仔细的代码审查和单元测试，确保对象在不再需要时能够正确地被释放和垃圾回收。</p>
</li>
</ul>
<p>内存管理是Java应用程序性能优化的关键一部分。通过合理设置堆内存大小、及时发现和解决内存泄漏问题，以及了解内存分配和垃圾回收的工作原理，你可以提高应用程序的性能、稳定性和可维护性。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>垃圾收集是Java应用程序内存管理的核心方面，它旨在自动回收不再使用的内存，以提高应用程序的性能和稳定性。以下是有关垃圾收集的详细信息：</p>
<h3 id="垃圾收集的作用"><a href="#垃圾收集的作用" class="headerlink" title="垃圾收集的作用"></a>垃圾收集的作用</h3><ol>
<li><p><strong>释放不再使用的内存</strong>：垃圾收集的主要目标是识别并回收不再被引用的对象，以释放内存。这防止了内存泄漏，确保应用程序能够持续运行而不会耗尽内存。</p>
</li>
<li><p><strong>提高开发效率</strong>：开发人员不需要手动释放内存，因为垃圾收集器会处理这个任务。这减轻了程序员的负担，并减少了出错的机会。</p>
</li>
<li><p><strong>减少内存碎片</strong>：垃圾收集器可以在内存中移动对象，以减少内存碎片。这有助于减少不规则的内存分配，提高了内存的使用效率。</p>
</li>
<li><p><strong>降低停顿时间</strong>：一些现代垃圾收集器（如G1收集器）专注于减少长时间停顿，从而提高了应用程序的响应性。</p>
</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><p>Java虚拟机实现了多种垃圾收集算法，以满足不同应用程序的需求。以下是一些常见的垃圾收集算法：</p>
<ol>
<li><p><strong>标记-清除算法（Mark and Sweep）</strong>：这是最基本的垃圾收集算法。它首先标记所有可达对象，然后清除未标记的对象。这种方法可能导致内存碎片。</p>
</li>
<li><p><strong>复制算法（Copying）</strong>：它将堆分为两部分，一部分用于存储对象，另一部分保持为空。垃圾收集时，将活动对象从一个空间复制到另一个空间，然后清除旧空间。这减少了内存碎片，但需要额外的复制操作。</p>
</li>
<li><p><strong>标记-整理算法（Mark and Compact）</strong>：类似于标记-清除算法，但在清除后，它会将存活对象紧凑排列，从而减少内存碎片。</p>
</li>
<li><p><strong>分代垃圾收集</strong>：这种方法将堆内存分为不同的代，通常分为新生代和老年代。新对象首先分配在新生代，然后通过不同的垃圾收集算法进行回收。老年代用于存放长时间存活的对象。</p>
</li>
</ol>
<h3 id="垃圾收集器的选择"><a href="#垃圾收集器的选择" class="headerlink" title="垃圾收集器的选择"></a>垃圾收集器的选择</h3><p>Java虚拟机提供了多种垃圾收集器，开发人员可以根据应用程序的性能需求进行选择。以下是一些常见的垃圾收集器：</p>
<ol>
<li><p><strong>Serial收集器</strong>：适用于单线程应用程序，使用标记-清除算法。</p>
</li>
<li><p><strong>Parallel收集器</strong>：适用于多核处理器，使用标记-整理算法，提供更高的吞吐量。</p>
</li>
<li><p><strong>CMS（Concurrent Mark-Sweep）收集器</strong>：适用于需要低停顿时间的应用程序，使用标记-清除算法，部分阶段是并发执行的。</p>
</li>
<li><p><strong>G1（Garbage-First）收集器</strong>：适用于大内存应用程序，使用分代垃圾收集，以及标记-整理算法。它旨在减少长时间停顿。</p>
</li>
</ol>
<h3 id="垃圾收集的性能优化"><a href="#垃圾收集的性能优化" class="headerlink" title="垃圾收集的性能优化"></a>垃圾收集的性能优化</h3><p>为了优化垃圾收集性能，可以考虑以下策略：</p>
<ol>
<li><p><strong>选择合适的垃圾收集器</strong>：根据应用程序的性能需求和硬件配置来选择最合适的垃圾收集器。</p>
</li>
<li><p><strong>调整垃圾收集器参数</strong>：使用垃圾收集器相关的参数来调整垃圾收集的频率、停顿时间等参数。</p>
</li>
<li><p><strong>避免创建不必要的对象</strong>：减少对象的创建可以降低垃圾收集的压力。</p>
</li>
<li><p><strong>合理分配堆内存大小</strong>：通过合理设置堆内存大小，可以减少垃圾收集的频率。</p>
</li>
<li><p>**定期执行性能分析</p>
</li>
</ol>
<h2 id="线程优化"><a href="#线程优化" class="headerlink" title="线程优化"></a>线程优化</h2><h2 id="线程优化-1"><a href="#线程优化-1" class="headerlink" title="线程优化"></a>线程优化</h2><p>线程优化在多线程的Java应用程序中至关重要，它可以提高应用程序的并发性能、可伸缩性和资源利用率。以下是一些线程优化的关键策略：</p>
<h3 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h3><p>线程池是一种管理和重用线程的机制，可以有效地处理并发任务，减少线程创建和销毁的开销。以下是线程池的一些关键考虑因素：</p>
<ul>
<li><p><strong>线程池类型的选择</strong>：Java提供了不同类型的线程池，如FixedThreadPool、CachedThreadPool、ScheduledThreadPool等。根据应用程序的需求选择合适的线程池类型。</p>
</li>
<li><p><strong>线程池大小的调整</strong>：线程池的大小应根据应用程序的负载情况进行调整。太小的线程池可能导致性能瓶颈，而太大的线程池可能浪费资源。</p>
</li>
<li><p><strong>任务队列的管理</strong>：线程池通常使用任务队列来存储等待执行的任务。合理选择任务队列的类型和大小，以防止任务堆积或资源浪费。</p>
</li>
</ul>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全是多线程应用程序中至关重要的概念。线程安全意味着多个线程可以同时访问共享数据而不会导致数据不一致或竞态条件。以下是一些线程安全的实践：</p>
<ul>
<li><p><strong>使用同步机制</strong>：使用synchronized关键字、ReentrantLock等同步机制来保护共享资源，以确保多线程访问的安全性。</p>
</li>
<li><p><strong>不可变对象</strong>：设计不可变对象，它们在创建后不能被修改，从而避免了线程安全问题。</p>
</li>
<li><p><strong>并发数据结构</strong>：Java提供了许多并发数据结构，如ConcurrentHashMap、CopyOnWriteArrayList等，用于支持高并发的数据访问。</p>
</li>
</ul>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>死锁是一种常见的多线程问题，其中多个线程互相等待对方释放资源，导致应用程序无法继续执行。以下是一些建议来避免死锁：</p>
<ul>
<li><p><strong>按顺序获取锁</strong>：如果需要多个锁，尝试按照相同的顺序获取它们，以减少死锁的可能性。</p>
</li>
<li><p><strong>使用超时机制</strong>：在获取锁时设置超时，以防止线程无限期等待。</p>
</li>
<li><p><strong>定期检查和恢复</strong>：定期检查死锁并采取措施来解除死锁，如终止某个线程。</p>
</li>
</ul>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能分析是线程优化的关键步骤，它可以帮助你识别性能瓶颈和瓶颈的原因。以下是一些建议：</p>
<ul>
<li><p><strong>使用性能分析工具</strong>：工具如VisualVM、YourKit、JProfiler等可以帮助你监视应用程序的性能，并发现性能问题。</p>
</li>
<li><p><strong>性能测试和基准测试</strong>：执行性能测试和基准测试，以了解应用程序在不同负载条件下的性能表现。这有助于识别性能问题并进行改进。</p>
</li>
</ul>
<p>线程优化是多线程Java应用程序开发的关键一部分。通过合理使用线程池、确保线程安全、避免死锁和进行性能分析，你可以提高应用程序的并发性能和可靠性。</p>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><h3 id="JVM性能分析工具"><a href="#JVM性能分析工具" class="headerlink" title="JVM性能分析工具"></a>JVM性能分析工具</h3><p>JVM性能分析工具是用于监视和分析Java虚拟机（JVM）运行时性能的工具集。这些工具帮助开发人员和系统管理员识别应用程序性能瓶颈、内存泄漏和其他性能问题。以下是一些常见的JVM性能分析工具和它们的用途：</p>
<h3 id="1-VisualVM"><a href="#1-VisualVM" class="headerlink" title="1. VisualVM"></a>1. <strong>VisualVM</strong></h3><ul>
<li><p><strong>用途</strong>：VisualVM是一种图形化工具，用于监视应用程序的性能和分析内存使用情况。它可以连接到本地或远程JVM进程，并提供堆转储、线程分析、垃圾收集统计等功能。</p>
</li>
<li><p><strong>优势</strong>：易于使用，可视化界面，免费，支持各种插件。</p>
</li>
</ul>
<h3 id="2-YourKit"><a href="#2-YourKit" class="headerlink" title="2. YourKit"></a>2. <strong>YourKit</strong></h3><ul>
<li><p><strong>用途</strong>：YourKit是一种商业性能分析工具，用于实时监视和分析JVM性能。它提供CPU和内存分析，线程跟踪，堆转储分析等功能。</p>
</li>
<li><p><strong>优势</strong>：高度专业，低开销，支持各种应用服务器，强大的分析功能。</p>
</li>
</ul>
<h3 id="3-Java-Mission-Control-JMC"><a href="#3-Java-Mission-Control-JMC" class="headerlink" title="3. Java Mission Control (JMC)"></a>3. <strong>Java Mission Control (JMC)</strong></h3><ul>
<li><p><strong>用途</strong>：JMC是Oracle官方提供的性能监控和分析工具，用于分析Java应用程序的性能和行为。它包括事件记录、垃圾收集分析、线程分析等功能。</p>
</li>
<li><p><strong>优势</strong>：集成于JVM，无需额外配置，提供全面的性能分析工具。</p>
</li>
</ul>
<h3 id="4-JProfiler"><a href="#4-JProfiler" class="headerlink" title="4. JProfiler"></a>4. <strong>JProfiler</strong></h3><ul>
<li><p><strong>用途</strong>：JProfiler是一种商业性能分析工具，用于实时监视和分析Java应用程序性能。它支持CPU和内存分析，线程分析，数据库查询分析等功能。</p>
</li>
<li><p><strong>优势</strong>：功能丰富，易于使用，支持各种应用服务器，可用于性能调优。</p>
</li>
</ul>
<h3 id="5-Eclipse-MAT-Memory-Analyzer-Tool"><a href="#5-Eclipse-MAT-Memory-Analyzer-Tool" class="headerlink" title="5. Eclipse MAT (Memory Analyzer Tool)"></a>5. <strong>Eclipse MAT (Memory Analyzer Tool)</strong></h3><ul>
<li><p><strong>用途</strong>：Eclipse MAT是一种内存分析工具，专注于分析Java应用程序的内存使用情况。它可以帮助识别内存泄漏和优化内存使用。</p>
</li>
<li><p><strong>优势</strong>：开源，专注于内存分析，可与Eclipse IDE集成。</p>
</li>
</ul>
<h3 id="6-Flight-Recorder"><a href="#6-Flight-Recorder" class="headerlink" title="6. Flight Recorder"></a>6. <strong>Flight Recorder</strong></h3><ul>
<li><p><strong>用途</strong>：Flight Recorder是Oracle JDK的一部分，用于实时监视和记录JVM的性能数据。它提供事件记录、垃圾收集分析、线程分析等功能。</p>
</li>
<li><p><strong>优势</strong>：集成于Oracle JDK，无需额外安装，轻量级，适用于生产环境。</p>
</li>
</ul>
<h2 id="性能测试和基准测试"><a href="#性能测试和基准测试" class="headerlink" title="性能测试和基准测试"></a>性能测试和基准测试</h2><p>性能测试和基准测试是评估和优化应用程序性能的关键步骤。它们帮助开发人员识别性能问题、性能瓶颈和不断改进应用程序的性能。以下是有关性能测试和基准测试的详细信息：</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>性能测试是一种评估应用程序在不同负载条件下的性能的测试方法。它有以下主要类型：</p>
<ol>
<li><p><strong>负载测试</strong>：在不同负载条件下测试应用程序的性能，以评估其在高负载时的响应性。</p>
</li>
<li><p><strong>压力测试</strong>：通过模拟高负载情况，测试应用程序的稳定性和性能极限。</p>
</li>
<li><p><strong>稳定性测试</strong>：验证应用程序在持续运行时的稳定性，检测内存泄漏和资源泄漏。</p>
</li>
<li><p><strong>并发性测试</strong>：评估应用程序在多个并发用户或请求下的性能。</p>
</li>
</ol>
<h3 id="基准测试"><a href="#基准测试" class="headerlink" title="基准测试"></a>基准测试</h3><p>基准测试是一种用于测量应用程序性能的测试方法，通常与性能测试结合使用。基准测试的目标是建立一个性能基准，以便将来的测试可以与之比较。以下是一些基准测试的关键概念：</p>
<ol>
<li><p><strong>性能基准</strong>：性能基准是应用程序在特定条件下的性能度量，例如响应时间、吞吐量和资源利用率。</p>
</li>
<li><p><strong>构建基准测试</strong>：为了建立性能基准，你需要执行一系列测试，记录性能度量值，并计算平均值和标准差。</p>
</li>
<li><p><strong>迭代和比较</strong>：将来的性能测试可以与基准测试进行比较，以评估性能改进或性能退化。</p>
</li>
</ol>
<h3 id="性能测试和基准测试的步骤"><a href="#性能测试和基准测试的步骤" class="headerlink" title="性能测试和基准测试的步骤"></a>性能测试和基准测试的步骤</h3><p>执行性能测试和基准测试通常包括以下步骤：</p>
<ol>
<li><p><strong>定义测试目标</strong>：明确性能测试的目标，包括性能指标、负载条件和测试场景。</p>
</li>
<li><p><strong>设置测试环境</strong>：创建一个与生产环境相似的测试环境，包括硬件、网络配置和数据库。</p>
</li>
<li><p><strong>设计测试用例</strong>：确定测试用例，包括输入数据、请求频率和测试脚本。</p>
</li>
<li><p><strong>执行测试</strong>：运行性能测试并记录性能度量值，如响应时间、吞吐量和资源利用率。</p>
</li>
<li><p><strong>分析结果</strong>：使用性能分析工具来分析测试结果，识别性能问题和瓶颈。</p>
</li>
<li><p><strong>改进性能</strong>：根据分析的结果，采取措施来改进应用程序的性能，如代码优化、配置调整等。</p>
</li>
<li><p><strong>重复测试</strong>：执行重复测试以验证性能改进的效果，并确保不引入新的性能问题。</p>
</li>
</ol>
<h2 id="Java性能测试和基准测试工具"><a href="#Java性能测试和基准测试工具" class="headerlink" title="Java性能测试和基准测试工具"></a>Java性能测试和基准测试工具</h2><p>在Java开发中，有多种工具可供开发人员执行性能测试和基准测试，以评估应用程序的性能和建立性能基准。以下是一些与性能测试和基准测试相关的Java工具：</p>
<h3 id="1-Apache-JMeter"><a href="#1-Apache-JMeter" class="headerlink" title="1. Apache JMeter"></a>1. Apache JMeter</h3><ul>
<li><p><strong>用途</strong>：Apache JMeter是一款功能强大的开源工具，用于执行性能测试和负载测试。它支持模拟各种负载条件和协议，包括HTTP、HTTPS、FTP等。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://jmeter.apache.org/">Apache JMeter</a></p>
</li>
</ul>
<h3 id="2-Apache-Benchmark-ab"><a href="#2-Apache-Benchmark-ab" class="headerlink" title="2. Apache Benchmark (ab)"></a>2. Apache Benchmark (ab)</h3><ul>
<li><p><strong>用途</strong>：Apache Benchmark是一个轻量级的命令行工具，通常用于执行HTTP性能测试。它可用于测试Web服务器的性能。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://httpd.apache.org/docs/2.4/programs/ab.html">Apache Benchmark</a></p>
</li>
</ul>
<h3 id="3-Gatling"><a href="#3-Gatling" class="headerlink" title="3. Gatling"></a>3. Gatling</h3><ul>
<li><p><strong>用途</strong>：Gatling是一款开源性能测试工具，专注于测试Web应用程序的性能。它使用Scala编写，并提供DSL（领域特定语言）来定义性能测试场景。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://gatling.io/">Gatling</a></p>
</li>
</ul>
<h3 id="4-VisualVM"><a href="#4-VisualVM" class="headerlink" title="4. VisualVM"></a>4. VisualVM</h3><ul>
<li><p><strong>用途</strong>：VisualVM是Java虚拟机监视、管理和性能分析工具。它可用于监视应用程序的性能、内存使用情况和线程行为。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://visualvm.github.io/">VisualVM</a></p>
</li>
</ul>
<h3 id="5-YourKit-Profiler"><a href="#5-YourKit-Profiler" class="headerlink" title="5. YourKit Profiler"></a>5. YourKit Profiler</h3><ul>
<li><p><strong>用途</strong>：YourKit是一款商业性能分析工具，用于分析Java应用程序的性能、内存使用情况和线程行为。它提供了强大的性能分析功能。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://www.yourkit.com/">YourKit</a></p>
</li>
</ul>
<h3 id="6-Java-Mission-Control-JMC"><a href="#6-Java-Mission-Control-JMC" class="headerlink" title="6. Java Mission Control (JMC)"></a>6. Java Mission Control (JMC)</h3><ul>
<li><p><strong>用途</strong>：Java Mission Control是Oracle官方提供的性能监控和分析工具，用于监视和分析Java应用程序的性能、垃圾收集和线程行为。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://www.oracle.com/java/technologies/javase/jmc.html">Java Mission Control</a></p>
</li>
</ul>
<h3 id="7-JMH-Java-Microbenchmarking-Harness"><a href="#7-JMH-Java-Microbenchmarking-Harness" class="headerlink" title="7. JMH (Java Microbenchmarking Harness)"></a>7. JMH (Java Microbenchmarking Harness)</h3><ul>
<li><p><strong>用途</strong>：JMH是Java的微基准测试框架，用于精确测量Java代码的性能。它可用于编写和运行微基准测试。</p>
</li>
<li><p><strong>链接</strong>：<a href="https://openjdk.java.net/projects/code-tools/jmh/">JMH</a></p>
</li>
</ul>
<p>扩展阅读<br><a href="https://maping930883.blogspot.com/2016/07/java027-ibm-thread-dump-analyzer-thread.html">使用 IBM Thread Dump Analyzer 分析 Thread Dump</a></p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[webpack搭建react构建环境]]></title>
      <url>http://blog.00ps.win/2016/12/16/webpack%25E6%2590%25AD%25E5%25BB%25BAreact%25E6%259E%2584%25E5%25BB%25BA%25E7%258E%25AF%25E5%25A2%2583/</url>
      <content type="html"><![CDATA[<h1 id="Babel和Webpack"><a href="#Babel和Webpack" class="headerlink" title="Babel和Webpack"></a>Babel和Webpack</h1><p>事实上react并不需要这些工具就能运行；但是为了充分使用 <a href="https://github.com/lukehoban/es6features" target="_blank" rel="external">ES6</a>、<a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">JSX</a> 和bunding</p>
<a id="more"></a>
<h1 id="让我们重新配置"><a href="#让我们重新配置" class="headerlink" title="让我们重新配置"></a>让我们重新配置</h1><p>新建一个react-hello-world文件夹并用npm初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir react-hello-world</div><div class="line">cd react-hello-world</div><div class="line">npm init</div></pre></td></tr></table></figure></p>
<h1 id="安装并配置webpack"><a href="#安装并配置webpack" class="headerlink" title="安装并配置webpack"></a>安装并配置webpack</h1><p><a href="https://facebook.github.io/react/docs/jsx-in-depth.html" target="_blank" rel="external">Webpack</a>可以根据配置文件将依赖文件和资源文件打包在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 安装并保存webpack到package.json里面</div><div class="line">npm install webpack —save-dev</div><div class="line"># 安装webpack的全局命令</div><div class="line">npm install -g webpack-cli</div></pre></td></tr></table></figure></p>
<p>webpack需要一些配置来指定他如何工作，最佳实践就是把配置写进去webpack.config.js<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> BUILD_DIR = path.resolve(__dirname, <span class="string">'build'</span>);</div><div class="line"><span class="keyword">var</span> APP_DIR = path.resolve(__dirname, <span class="string">'src'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="attr">entry</span>: &#123;</div><div class="line">    <span class="string">'index_bundle.js'</span>: path.resolve(APP_DIR, <span class="string">'index.js'</span>),</div><div class="line">  &#125;</div><div class="line">  output: &#123;</div><div class="line">    <span class="attr">path</span>: BUILD_DIR,</div><div class="line">    <span class="comment">// [name]指的是entry对象里面的key</span></div><div class="line">    filename: <span class="string">'[name]'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = config;</div></pre></td></tr></table></figure><br>以上是webpack配置文件的最小化配置，只需要提供entry(入口)和output(输出)</p>
<p><code>APP_DIR</code>是源码文件夹，<code>BUILD_DIR</code>是最终打包生成输出的文件夹</p>
<p>在src下创建<code>index.js</code>验证下此配置<br><figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="string">'Hello World!'</span>);</div></pre></td></tr></table></figure><br>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -d</div></pre></td></tr></table></figure></p>
<p>上面命令运行了webpack的开发模式，它会生成build/index_bundle.js和关联build/index_bundle.js的映射文件index_build.js.map</p>
<p>为了得到更多的交互我们创建index.html<br><figure class="highlight html"><figcaption><span>index.html</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React.js use jsx and es6<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bundle/index_bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><br>现在我们打开index.html，会在浏览器的console中看到输出</p>
<p>NOTE: <a href="https://github.com/webpack/html-loader" target="_blank" rel="external">html-loader</a>允许我们自动生成上述index.html文件</p>
<h1 id="激活babel"><a href="#激活babel" class="headerlink" title="激活babel"></a>激活babel</h1><p>jsx和es6让react能让有更高的开发效率，但是目前几乎所有浏览器都不支持。</p>
<p>因此我们需要个工具来转换他们，令到浏览器能识别，它就是<a href="http://babeljs.io/" target="_blank" rel="external">babel</a></p>
<figure class="highlight plain"><figcaption><span>转换流程</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</div><div class="line">&gt;  &lt;p&gt;Hello&lt;/p&gt;  &gt;  ===&gt;    &gt;  babel-loader  &gt;  ===&gt; &gt;  React.createElement(&apos;p&apos;, ...)  &gt;</div><div class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</div><div class="line">     index.js                    webpack                       index_bundle.js</div><div class="line"></div></pre></td></tr></table></figure>
<p>安装babel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i babel-core babel-loader babel-preset-es2015 babel-preset-react --save-dev</div></pre></td></tr></table></figure></p>
<p><code>babel-preset-es2015</code>和<code>babel-preset-react</code>是<code>babel-loader</code>的插件，用来转换es6和jsx</p>
<p>babel-loader是读取一个配置文件，所以能在配置文件中声明使用转换es6和react的插件<br><figure class="highlight js"><figcaption><span>.babelrc</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"presets"</span> : [<span class="string">"es2015"</span>, <span class="string">"react"</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下一步我们使用babel-loader来打包文件<br><figure class="highlight js"><figcaption><span>webpack.config.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Existing Code ....</span></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="comment">// Existing Code ....</span></div><div class="line">  <span class="built_in">module</span> : &#123;</div><div class="line">    <span class="attr">loaders</span> : [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span> : <span class="regexp">/\.js$/</span>,</div><div class="line">        <span class="attr">include</span> : APP_DIR,</div><div class="line">        <span class="attr">loader</span> : <span class="string">'babel'</span></div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>loaders</code>接收一组loader，我们只使用了babel-loader。每个loader都会处理匹配<code>test</code>内容的文件。 这里我们配置了babel-loader处理.js后缀的文件。loader会在<code>include</code>指定的文件夹中遍历寻找符合<code>test</code>规则的文件。</p>
<p>目前所有配置都准备就绪了。让我们写点react吧</p>
<h1 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h1><p>安装react和react-dom<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i react react-dom --save</div></pre></td></tr></table></figure></p>
<figure class="highlight js"><figcaption><span>src/index.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;render&#125; <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render () &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span> Hello React!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>));</div></pre></td></tr></table></figure>
<p>如果还打开着index.html页面，刷新下会看到<em>Hello React!</em></p>
<h1 id="webpack监听文件更改"><a href="#webpack监听文件更改" class="headerlink" title="webpack监听文件更改"></a>webpack监听文件更改</h1><p>每次更改都需要手动运行命令，这不是一个高效的工作流。我们可以很简单的使用以下命令来监听文件修改<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack -d --watch</div></pre></td></tr></table></figure></p>
<p>现在以watch模式运行着webpack，当文件更改或者删除的时候会自动生成bundel。我们可以试试修改src/index.js，然后刷新浏览器看效果</p>
<h1 id="让一切”自动”起来"><a href="#让一切”自动”起来" class="headerlink" title="让一切”自动”起来"></a>让一切”自动”起来</h1><p>为了能更专心coding，我们希望能<code>所编即所见</code>。我们需要用到<a href="https://webpack.github.io/docs/webpack-dev-server.html" target="_blank" rel="external">webpack-dev-server</a><br><figure class="highlight plain"><figcaption><span>安装webpack-dev-server命令行工具</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i -g webpack-dev-server</div></pre></td></tr></table></figure><br>webpack-dev-server能提供server服务和监听修改刷新浏览器，让我们配置下它<br><figure class="highlight js"><figcaption><span>webpack.coding.js</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Existing Code ....</span></div><div class="line"><span class="keyword">var</span> config = &#123;</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="comment">// Existing Code ....</span></div><div class="line">    filename: <span class="string">'[name]'</span>,</div><div class="line">    <span class="comment">// webpack-dev-server 输出路径</span></div><div class="line">    publicPath: <span class="string">'/build/'</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Existing Code ....</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><br><code>publicPath</code>是webpack-dev-server输出文件的路径，这只是个映射，映射到内存中的一部分，并不真的会在build下生成文件。</p>
<p>启动服务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">webpack-dev-server</div></pre></td></tr></table></figure></p>
<p>我们就可以通过<a href="http://localhost:8080/webpack-dev-server/" target="_blank" rel="external">http://localhost:8080/webpack-dev-server/</a>来访问到index.html文件。现在试下做下修改看浏览器有什么变化？</p>
]]></content>
      
        <categories>
            
            <category> web前端 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react-native笔记-基础篇]]></title>
      <url>http://blog.00ps.win/2016/11/23/react-native%25E7%25AC%2594%25E8%25AE%25B0-%25E5%259F%25BA%25E7%25A1%2580%25E7%25AF%2587/</url>
      <content type="html"><![CDATA[<p>#Component</p>
<ul>
<li>定义组件首字必须大小，用于区分普通html元素</li>
</ul>
<h1 id="props"><a href="#props" class="headerlink" title="props"></a>props</h1><p>可用于定制组件，等同于htm中的attribute。<br>贯穿整个生命周期，不得做任何改变<br><a id="more"></a></p>
<h2 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><a href="https://facebook.github.io/react/docs/react-component.html#defaultprops" target="_blank" rel="external">defaultProps</a></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#proptypes" target="_blank" rel="external">proptypes</a></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#props" target="_blank" rel="external">props</a><br>this.props.children该组件下的子组件</li>
</ul>
<h1 id="state"><a href="#state" class="headerlink" title="state"></a>state</h1><p>跟props一样用于定制组件用，不同的是state可以被修改<br>在构造器初始化，当你想改变组件状态的时候调用setState，<br>组件重新render，除非shouldComponentUpdate()返回false</p>
<h2 id="主要属性-1"><a href="#主要属性-1" class="headerlink" title="主要属性"></a>主要属性</h2><ul>
<li><a href="https://facebook.github.io/react/docs/react-component.html#state" target="_blank" rel="external">state</a><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2></li>
<li><a href="https://facebook.github.io/react/docs/react-component.html#setstate" target="_blank" rel="external">setState</a><br>此方法不是重新设置state，而是合并</li>
</ul>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul>
<li><a href="https://facebook.github.io/react/docs/state-and-lifecycle.html" target="_blank" rel="external">State and Lifecycle</a></li>
<li><a href="http://redux.js.org/index.html" target="_blank" rel="external">更好的控制状态Redux</a></li>
</ul>
<h1 id="style"><a href="#style" class="headerlink" title="style"></a>style</h1><p>跟html的style差不多，不同的是background-color这些要写成backgroundColor。<br>style能是普通的js对象，也能是使用StyleSheet.create来创建。<br>更推荐的是使用StyleSheet.create在组件的同一个地方创建</p>
<h2 id="StyleSheet-create-vs-普通js对象"><a href="#StyleSheet-create-vs-普通js对象" class="headerlink" title="StyleSheet.create vs 普通js对象"></a>StyleSheet.create vs 普通js对象</h2><ul>
<li>StyleSheet.create创建返回的是一个id，通过StyleSheetRegistry.getStyleByID获取该id<br>指向的对象</li>
<li>用StyleSheet.create创建代替每次都创建新的对象</li>
</ul>
]]></content>
      
        <categories>
            
            <category> react native </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react react-native </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[安装httpd并整合tomcat]]></title>
      <url>http://blog.00ps.win/2015/05/02/%25E5%25AE%2589%25E8%25A3%2585httpd%25E5%25B9%25B6%25E6%2595%25B4%25E5%2590%2588tomcat/</url>
      <content type="html"><![CDATA[<h1 id="安装httpd"><a href="#安装httpd" class="headerlink" title="安装httpd"></a>安装httpd</h1><p>下载<a href="http://httpd.apache.org/">httpd</a>并解压<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weget http://mirrors.hust.edu.cn/apache//httpd/httpd-2.2.29.tar.gz</span><br><span class="line">tar -zxvf httpd-2.2.29.tar.gz</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>配置编译安装<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd httpd-2.2.29</span><br><span class="line"><span class="meta">#</span><span class="bash">prefix是指定了安装位置</span></span><br><span class="line">./configure --prefix=/usr/local/apache2 \      # 安装目录</span><br><span class="line">--enable-modules=most \                        # 大部分模块静态编译到httpd的二进制文件中</span><br><span class="line">--enable-mods-shared=all \                     # 表示动态加载所有模块,如果去掉shared的话,是静态加载所有模块</span><br><span class="line">--enable-so \</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<p>以上没有错误就启动httpd, 注意:因为还没加进服务，所以需要到httpd安装目录下用前端控制工具启动(不能用service httpd start)<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/apache2/bin/apachectl start</span><br></pre></td></tr></table></figure><br>打开浏览器浏览<a href="http://localhost">http://localhost</a>看见It’s ok就代表httpd安装并启动成功了</p>
<p>加进服务和开机启动<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/apache2/bin/apachectl /init.d/httpd</span><br><span class="line">ln -s /etc/init.d/httpd /etc/rc.d/rc5.d/S85httpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行chkconfig --list发现列表中并没有httpd,通过chkconfig --add httpd来添加,</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可能会提示httpd服务不支持chkconfig,需要编辑/etc/init.d/httpd,加入注析<span class="comment">#chkconfig 345 85 15</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 345代表哪些linux级别需要启动httpd,启动序号85 关闭序号15</span></span><br><span class="line">chkconfig --add httpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现存在了</span></span><br><span class="line">chkconfig --list httpd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来就可能用service http命令关闭和启动httpd了</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加进开机启动</span></span><br><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure></p>
<h1 id="整合tomcat"><a href="#整合tomcat" class="headerlink" title="整合tomcat"></a>整合tomcat</h1><p>在/usr/local/apache2/conf/httpd.conf最后加上Include conf/extra/tomcat-vhosts.conf,<br>编辑/usr/local/apache2/conf/extra/tomcat-vhosts.conf<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># enable name virtual</span><br><span class="line">NameVirtualHost *:80</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">VirtualHost</span> *<span class="attr">:80</span>&gt;</span></span><br><span class="line">  ServerName test.h4fan.com</span><br><span class="line">  DocumentRoot /path/to/project/root</span><br><span class="line">  ProxyPass / http://localhost:8080/</span><br><span class="line">  ProxyPassReverse / http://localhost:8080/</span><br><span class="line">  ErrorLog &quot;logs/test-error.log&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">VirtualHost</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>重启httpd,发现出错了<br><em>Invalid command ‘ProxyPass’, perhaps misspelled or defined by a module not included in the server configuration</em><br>需要安装proxy等模块</p>
<p>介绍下添加模块的命令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/apache2/bin/apxs -c -i -a mod_proxy.c proxy_util.c</span><br></pre></td></tr></table></figure><br>说明:<br>-c 执行编译操作<br>-i 安装操作,安装一个或多个动态共享对象到modules目录<br>-a 自动增加一个LoadModule到httpd.conf文件,以激活模块,若此存在则启动之<br>-A 与-a类似,但是它增加的LoadModule前面加有#<br>-e 需要执行编辑操作,可与-a和-A选项配合使用,与-i操作类似,修改httpd.conf文件,但并不安装此模块</p>
<p>切换到源代码目录下的/modules/proxy,执行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/usr/<span class="built_in">local</span>/apache2/bin/apxs -c -i -a mod_proxy.c proxy_util.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/usr/<span class="built_in">local</span>/apache2/bin/apxs -c -i -a mod_proxy_http.c</span></span><br><span class="line"><span class="meta">#</span><span class="bash">/usr/<span class="built_in">local</span>/apache2/bin/apxs -c -i -a mod_proxy_ajp.c ajp*.c</span></span><br></pre></td></tr></table></figure></p>
<p>现在再启动httpd就没出错了</p>
]]></content>
      
        <categories>
            
            <category> 服务器 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tomcat </tag>
            
            <tag> apache httpd </tag>
            
            <tag> linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[判断指定区间(或操作符实现)]]></title>
      <url>http://blog.00ps.win/2014/10/22/%25E5%2588%25A4%25E6%2596%25AD%25E6%258C%2587%25E5%25AE%259A%25E5%258C%25BA%25E9%2597%25B4-%25E6%2588%2596%25E6%2593%258D%25E4%25BD%259C%25E7%25AC%25A6%25E5%25AE%259E%25E7%258E%25B0/</url>
      <content type="html"><![CDATA[<p>一般求一个值是否在指定区间为i&gt;=min&amp;&amp;i&lt;=max，但今天从网上看到这么一种写法((i-min)|(max-i))&gt;=0，原理很简单，只要i-min或者max-i其中为负数的时候，说明已经超出了区间，或操作得出的数字必定为负数</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
    </entry>
    
  
  
</search>
